#ifndef FUNCS_H
#define FUNCS_H

#include "./api_structs.h"

bool							length_is_undefined(t_length length);
bool							point_eq(t_point a, t_point b);
bool							point_gt(t_point a, t_point b);
bool							point_gte(t_point a, t_point b);
bool							point_lt(t_point a, t_point b);
bool							point_lte(t_point a, t_point b);
bool							reusable_node_descend(t_reusable_node *self);
bool							set_contains(t_char_range *ranges, uint32_t len, int32_t lookahead);
bool							ts_external_scanner_state_eq(const t_external_scanner_state *self, const char *, uint32_t);
bool							ts_language_has_actions(const t_language *self, t_state_id state, t_symbol symbol);
bool							ts_language_has_reduce_action(const t_language *self, t_state_id state, t_symbol symbol);
bool							ts_language_is_symbol_external(const t_language *self, t_symbol symbol);
bool							ts_language_state_is_primary(const t_language *self, t_state_id state);
bool							ts_lexer_set_included_ranges(t_lexer *self, const t_parse_range *ranges, uint32_t count);
bool							ts_lookahead_iterator__next(t_lookahead_iterator *self);
bool							ts_range_array_intersects(const t_range_array *self, uint32_t start_index, uint32_t start_byte, uint32_t end_byte);
bool							ts_stack_can_merge(t_stack *, t_stack_version, t_stack_version);
bool							ts_stack_has_advanced_since_error(const t_stack *, t_stack_version);
bool							ts_stack_is_active(const t_stack *, t_stack_version);
bool							ts_stack_is_halted(const t_stack *, t_stack_version);
bool							ts_stack_is_paused(const t_stack *, t_stack_version);
bool							ts_stack_merge(t_stack *, t_stack_version, t_stack_version);
bool							ts_subtree_depends_on_column(t_subtree self);
bool							ts_subtree_external_scanner_state_eq(t_subtree, t_subtree);
bool							ts_subtree_extra(t_subtree self);
bool							ts_subtree_fragile_left(t_subtree self);
bool							ts_subtree_fragile_right(t_subtree self);
bool							ts_subtree_has_changes(t_subtree self);
bool							ts_subtree_has_external_scanner_state_change(t_subtree self);
bool							ts_subtree_has_external_tokens(t_subtree self);
bool							ts_subtree_has_external_tokens(t_subtree self);
bool							ts_subtree_is_eof(t_subtree self);
bool							ts_subtree_is_error(t_subtree self);
bool							ts_subtree_is_fragile(t_subtree self);
bool							ts_subtree_is_keyword(t_subtree self);
bool							ts_subtree_missing(t_subtree self);
bool							ts_subtree_named(t_subtree self);
bool							ts_subtree_visible(t_subtree self);
char						   *ts_subtree_string(t_subtree, t_symbol, bool, const t_language *, bool include_all);
const bool					   *ts_language_enabled_external_tokens(const t_language *self, uint32_t external_scanner_state);
const char					   *ts_external_scanner_state_data(const t_external_scanner_state *);
const t_external_scanner_state *ts_subtree_external_scanner_state(t_subtree self);
const t_parse_action		   *ts_language_actions(const t_language *self, t_state_id state, t_symbol symbol, uint32_t *count);
const t_symbol				   *ts_language_alias_sequence(const t_language *self, uint32_t production_id);
int								ts_stack_dynamic_precedence(t_stack *, t_stack_version);
int								ts_subtree_compare(t_subtree, t_subtree, t_subtree_pool *);
int32_t							ts_subtree_dynamic_precedence(t_subtree self);
size_t							atomic_load(const volatile size_t *p);
size_t							ts_subtree_alloc_size(uint32_t child_count);
t_first_tree				   *ts_tree_new(t_subtree root, const t_language *language, const t_parse_range *, uint32_t);
t_length						length_add(t_length len1, t_length len2);
t_length						length_min(t_length len1, t_length len2);
t_length						length_saturating_sub(t_length len1, t_length len2);
t_length						length_sub(t_length len1, t_length len2);
t_length						length_zero(void);
t_length						ts_stack_position(const t_stack *, t_stack_version);
t_length						ts_subtree_padding(t_subtree self);
t_length						ts_subtree_size(t_subtree self);
t_length						ts_subtree_total_size(t_subtree self);
t_lookahead_iterator			ts_language_lookaheads(const t_language *self, t_state_id state);
t_mutable_subtree				ts_subtree_make_mut(t_subtree_pool *, t_subtree);
t_mutable_subtree				ts_subtree_new_node(t_symbol, t_subtree_array *, uint32_t, const t_language *);
t_mutable_subtree				ts_subtree_to_mut_unsafe(t_subtree self);
t_parse_node					ts_node_new(const t_first_tree *, const t_subtree *, t_length, t_symbol);
t_parse_node					ts_tree_cursor_parent_node(const t_tree_cursor *);
t_parse_range				   *ts_lexer_included_ranges(const t_lexer *self, uint32_t *count);
t_point							point__new(uint32_t row, uint32_t column);
t_point							point_add(t_point a, t_point b);
t_point							point_max(t_point a, t_point b);
t_point							point_min(t_point a, t_point b);
t_point							point_sub(t_point a, t_point b);
t_reusable_node					reusable_node_new(void);
t_stack						   *ts_stack_new(t_subtree_pool *);
t_stack_slice_array				ts_stack_pop_all(t_stack *, t_stack_version);
t_stack_slice_array				ts_stack_pop_count(t_stack *, t_stack_version, uint32_t count);
t_stack_slice_array				ts_stack_pop_pending(t_stack *, t_stack_version);
t_stack_summary				   *ts_stack_get_summary(t_stack *, t_stack_version);
t_stack_version					ts_stack_copy_version(t_stack *, t_stack_version);
t_state_id						ts_language_next_state(const t_language *self, t_state_id state, t_symbol symbol);
t_state_id						ts_stack_state(const t_stack *, t_stack_version);
t_state_id						ts_subtree_leaf_parse_state(t_subtree self);
t_state_id						ts_subtree_parse_state(t_subtree self);
t_subtree						reusable_node_tree(t_reusable_node *self);
t_subtree						ts_stack_last_external_token(const t_stack *, t_stack_version);
t_subtree						ts_stack_resume(t_stack *, t_stack_version);
t_subtree						ts_subtree_edit(t_subtree, const t_input_edit *edit, t_subtree_pool *);
t_subtree						ts_subtree_from_mut(t_mutable_subtree self);
t_subtree						ts_subtree_last_external_token(t_subtree);
t_subtree						ts_subtree_new_error(t_subtree_pool *, int32_t, t_length, t_length, uint32_t, t_state_id, const t_language *);
t_subtree						ts_subtree_new_error_node(t_subtree_array *, bool, const t_language *);
t_subtree						ts_subtree_new_leaf(t_subtree_pool *, t_symbol, t_length, t_length, uint32_t, t_state_id, bool, bool, bool, const t_language *);
t_subtree						ts_subtree_new_missing_leaf(t_subtree_pool *, t_symbol, t_length, uint32_t, const t_language *);
t_subtree						ts_tree_cursor_current_subtree(const t_tree_cursor *_self);
t_subtree_array					ts_stack_pop_error(t_stack *, t_stack_version);
t_subtree_pool					ts_subtree_pool_new(uint32_t capacity);
t_symbol						ts_language_alias_at(const t_language *self, uint32_t production_id, uint32_t child_index);
t_symbol						ts_language_public_symbol(const t_language *, t_symbol);
t_symbol						ts_subtree_leaf_symbol(t_subtree self);
t_symbol						ts_subtree_symbol(t_subtree self);
t_symbol_metadata				ts_language_symbol_metadata(const t_language *, t_symbol);
t_tree_cursor_step				ts_tree_cursor_goto_first_child_internal(t_tree_cursor *);
t_tree_cursor_step				ts_tree_cursor_goto_next_sibling_internal(t_tree_cursor *);
uint16_t						ts_language_lookup(const t_language *self, t_state_id state, t_symbol symbol);
uint16_t						ts_subtree_production_id(t_subtree self);
uint32_t						atomic_dec(volatile uint32_t *p);
uint32_t						atomic_inc(volatile uint32_t *p);
uint32_t						reusable_node_byte_offset(t_reusable_node *self);
uint32_t						ts_stack_version_count(const t_stack *);
uint32_t						ts_subtree_child_count(t_subtree self);
uint32_t						ts_subtree_child_count(t_subtree self);
uint32_t						ts_subtree_error_cost(t_subtree self);
uint32_t						ts_subtree_is_repetition(t_subtree self);
uint32_t						ts_subtree_lookahead_bytes(t_subtree self);
uint32_t						ts_subtree_repeat_depth(t_subtree self);
uint32_t						ts_subtree_total_bytes(t_subtree self);
uint32_t						ts_subtree_total_bytes(t_subtree self);
uint32_t						ts_subtree_visible_child_count(t_subtree self);
uint32_t						ts_subtree_visible_descendant_count(t_subtree self);
uint32_t						ts_stack_error_cost(const t_stack *, t_stack_version version);
uint32_t						ts_stack_node_count_since_error(const t_stack *, t_stack_version);
uint32_t						ts_subtree_get_changed_ranges(const t_subtree *old_tree, const t_subtree *new_tree, t_tree_cursor *cursor1, t_tree_cursor *cursor2, const t_language *language, const t_range_array *included_range_differences, t_parse_range **ranges);
void							reusable_node_advance(t_reusable_node *self);
void							reusable_node_advance_past_leaf(t_reusable_node *self);
void							reusable_node_clear(t_reusable_node *self);
void							reusable_node_delete(t_reusable_node *self);
void							reusable_node_reset(t_reusable_node *self, t_subtree tree);
void							ts_external_scanner_state_delete(t_external_scanner_state *self);
void							ts_external_scanner_state_init(t_external_scanner_state *, const char *, uint32_t);
void							ts_language_aliases_for_symbol(const t_language *self, t_symbol original_symbol, const t_symbol **start, const t_symbol **end);
void							ts_language_field_map(const t_language *self, uint32_t production_id, const t_field_map_entry **start, const t_field_map_entry **end);
void							ts_language_table_entry(const t_language *, t_state_id, t_symbol, t_table_entry *);
void							ts_lexer_advance_to_end(t_lexer *lexer);
void							ts_lexer_delete(t_lexer *lexer);
void							ts_lexer_finish(t_lexer *lexer, uint32_t *);
void							ts_lexer_init(t_lexer *lexer);
void							ts_lexer_mark_end(t_lexer *lexer);
void							ts_lexer_reset(t_lexer *lexer, t_length);
void							ts_lexer_set_input(t_lexer *lexer, t_parse_input);
void							ts_lexer_start(t_lexer *lexer);
void							ts_range_array_get_changed_ranges(const t_parse_range *old_ranges, uint32_t old_range_count, const t_parse_range *new_ranges, uint32_t new_range_count, t_range_array *differences);
void							ts_reduce_action_set_add(t_reduce_action_set *self, t_reduce_action new_action);
void							ts_stack_clear(t_stack *);
void							ts_stack_delete(t_stack *);
void							ts_stack_halt(t_stack *, t_stack_version);
void							ts_stack_pause(t_stack *, t_stack_version, t_subtree);
void							ts_stack_push(t_stack *, t_stack_version, t_subtree, bool, t_state_id);
void							ts_stack_record_summary(t_stack *, t_stack_version, uint32_t max_depth);
void							ts_stack_remove_version(t_stack *, t_stack_version);
void							ts_stack_renumber_version(t_stack *, t_stack_version, t_stack_version);
void							ts_stack_set_last_external_token(t_stack *, t_stack_version, t_subtree);
void							ts_stack_swap_versions(t_stack *, t_stack_version, t_stack_version);
void							ts_subtree_array_clear(t_subtree_pool *, t_subtree_array *);
void							ts_subtree_array_copy(t_subtree_array, t_subtree_array *);
void							ts_subtree_array_delete(t_subtree_pool *, t_subtree_array *);
void							ts_subtree_array_remove_trailing_extras(t_subtree_array *, t_subtree_array *);
void							ts_subtree_array_reverse(t_subtree_array *);
void							ts_subtree_balance(t_subtree, t_subtree_pool *, const t_language *);
void							ts_subtree_pool_delete(t_subtree_pool *);
void							ts_subtree_release(t_subtree_pool *, t_subtree);
void							ts_subtree_retain(t_subtree);
void							ts_subtree_set_extra(t_mutable_subtree *self, bool is_extra);
void							ts_subtree_set_symbol(t_mutable_subtree *, t_symbol, const t_language *);
void							ts_subtree_summarize(t_mutable_subtree, const t_subtree *, uint32_t, const t_language *);
void							ts_subtree_summarize_children(t_mutable_subtree, const t_language *);
void							ts_tree_cursor_current_status(const t_tree_cursor *, t_field_id *, bool *, bool *, bool *, t_symbol *, uint32_t *);
void							ts_tree_cursor_init(t_tree_cursor *, t_parse_node);

#endif // FUNCS_H
