CaptureListPool				capture_list_pool_new(void);
CaptureList				   *capture_list_pool_get_mut(CaptureListPool *self, uint16_t id);
CaptureQuantifiers			capture_quantifiers_new(void);
Iterator					iterator_new(TreeCursor *cursor, const Subtree *tree, const TSLanguage *language);
IteratorComparison			iterator_compare(const Iterator *old_iter, const Iterator *new_iter);
Length						iterator_end_position(Iterator *self);
Length						iterator_start_position(Iterator *self);
QueryStep					query_step__new(TSSymbol symbol, uint16_t depth, bool is_immediate);
StackNode				   *stack_node_new(StackNode *previous_node, Subtree subtree, bool is_pending, TSStateId state, StackNodeArray *pool);
StackSliceArray				stack__iter(Stack *self, StackVersion version, StackCallback callback, void *payload, int goal_subtree_count);
Stream						stream_new(const char *string, uint32_t length);
SymbolTable					symbol_table_new(void);
TSQuantifier				capture_quantifier_for_id(const CaptureQuantifiers *self, uint16_t id);
TSQuantifier				quantifier_add(TSQuantifier left, TSQuantifier right);
TSQuantifier				quantifier_join(TSQuantifier left, TSQuantifier right);
TSQuantifier				quantifier_mul(TSQuantifier left, TSQuantifier right);
bool						capture_list_pool_is_empty(const CaptureListPool *self);
bool						iterator_descend(Iterator *self, uint32_t goal_position);
bool						iterator_done(Iterator *self);
bool						iterator_tree_is_visible(const Iterator *self);
bool						stack__subtree_is_equivalent(Subtree left, Subtree right);
bool						stream_advance(Stream *self);
bool						stream_is_ident_start(Stream *self);
const CaptureList		   *capture_list_pool_get(const CaptureListPool *self, uint16_t id);
const Length				LENGTH_MAX;
const Length				LENGTH_UNDEFINED;
const TSQueryError			PARENT_DONE;
const TSRange				DEFAULT_RANGE;
const TSSymbol				WILDCARD_SYMBOL;
const char				   *symbol_table_name_for_id(const SymbolTable *self, uint16_t id, uint32_t *length);
const char *const			ROOT_FIELD;
const int32_t				BYTE_ORDER_MARK;
const int32_t				TS_DECODE_ERROR;
const uint16_t				NONE;
const uint16_t				PATTERN_DONE_MARKER;
const unsigned				MAX_COST_DIFFERENCE;
const unsigned				MAX_SUMMARY_DEPTH;
const unsigned				MAX_VERSION_COUNT;
const unsigned				MAX_VERSION_COUNT_OVERFLOW;
const unsigned				OP_COUNT_PER_TIMEOUT_CHECK;
int							symbol_table_id_for_name(const SymbolTable *self, const char *name, uint32_t length);
uint16_t					capture_list_pool_acquire(CaptureListPool *self);
uint16_t					symbol_table_insert_name(SymbolTable *self, const char *name, uint32_t length);
uint32_t					stack__subtree_node_count(Subtree subtree);
uint32_t					stream_offset(Stream *self);
unsigned					analysis_state__recursion_depth(const AnalysisState *self);
void						capture_list_pool_delete(CaptureListPool *self);
void						capture_list_pool_release(CaptureListPool *self, uint16_t id);
void						capture_list_pool_reset(CaptureListPool *self);
void						capture_quantifiers_add_all(CaptureQuantifiers *self, CaptureQuantifiers *quantifiers);
void						capture_quantifiers_add_for_id(CaptureQuantifiers *self, uint16_t id, TSQuantifier quantifier);
void						capture_quantifiers_clear(CaptureQuantifiers *self);
void						capture_quantifiers_delete(CaptureQuantifiers *self);
void						capture_quantifiers_join_all(CaptureQuantifiers *self, CaptureQuantifiers *quantifiers);
void						capture_quantifiers_mul(CaptureQuantifiers *self, TSQuantifier quantifier);
void						capture_quantifiers_replace(CaptureQuantifiers *self, CaptureQuantifiers *quantifiers);
void						iterator_advance(Iterator *self);
void						iterator_ascend(Iterator *self);
void						iterator_get_visible_state(const Iterator *self, Subtree *tree, TSSymbol *alias_symbol, uint32_t *start_byte);
void						query_step__add_capture(QueryStep *self, uint16_t capture_id);
void						query_step__remove_capture(QueryStep *self, uint16_t capture_id);
void						stack_head_delete(StackHead *self, StackNodeArray *pool, SubtreePool *subtree_pool);
void						stack_node_add_link(StackNode *self, StackLink link, SubtreePool *subtree_pool);
void						stack_node_release(StackNode *self, StackNodeArray *pool, SubtreePool *subtree_pool);
void						stack_node_retain(StackNode *self);
void						stream_reset(Stream *self, const char *input);
void						stream_scan_identifier(Stream *stream);
void						stream_skip_whitespace(Stream *self);
void						symbol_table_delete(SymbolTable *self);
void					   *ts_calloc_default(size_t count, size_t size);
uint32_t					ts_decode_ascii(const uint8_t *string, uint32_t length, int32_t *code_point);
int							_ts_dup(int file_descriptor);
ExternalScannerState		ts_external_scanner_state_copy(const ExternalScannerState *self);
const char				   *ts_external_scanner_state_data(const ExternalScannerState *self);
void						ts_external_scanner_state_delete(ExternalScannerState *self);
bool						ts_external_scanner_state_eq(const ExternalScannerState *self, const char *buffer, unsigned length);
void						ts_external_scanner_state_init(ExternalScannerState *self, const char *data, unsigned length);
const TSLanguage		   *ts_language_copy(const TSLanguage *self);
void						ts_language_delete(const TSLanguage *self);
uint32_t					ts_language_field_count(const TSLanguage *self);
TSFieldId					ts_language_field_id_for_name(const TSLanguage *self, const char *name, uint32_t name_length);
const char				   *ts_language_field_name_for_id(const TSLanguage *self, TSFieldId id);
TSStateId					ts_language_next_state(const TSLanguage *self, TSStateId state, TSSymbol symbol);
TSSymbol					ts_language_public_symbol(const TSLanguage *self, TSSymbol symbol);
uint32_t					ts_language_state_count(const TSLanguage *self);
uint32_t					ts_language_symbol_count(const TSLanguage *self);
TSSymbol					ts_language_symbol_for_name(const TSLanguage *self, const char *string, uint32_t length, bool is_named);
TSSymbolMetadata			ts_language_symbol_metadata(const TSLanguage *self, TSSymbol symbol);
const char				   *ts_language_symbol_name(const TSLanguage *self, TSSymbol symbol);
TSSymbolType				ts_language_symbol_type(const TSLanguage *self, TSSymbol symbol);
void						ts_language_table_entry(const TSLanguage *self, TSStateId state, TSSymbol symbol, TableEntry *result);
uint32_t					ts_language_version(const TSLanguage *self);
void						ts_lexer__advance(TSLexer *_self, bool skip);
void						ts_lexer__clear_chunk(Lexer *self);
void						ts_lexer__do_advance(Lexer *self, bool skip);
bool						ts_lexer__eof(const TSLexer *_self);
void						ts_lexer__get_chunk(Lexer *self);
uint32_t					ts_lexer__get_column(TSLexer *_self);
void						ts_lexer__get_lookahead(Lexer *self);
bool						ts_lexer__is_at_included_range_start(const TSLexer *_self);
void						ts_lexer__mark_end(TSLexer *_self);
void						ts_lexer_advance_to_end(Lexer *self);
void						ts_lexer_delete(Lexer *self);
void						ts_lexer_finish(Lexer *self, uint32_t *lookahead_end_byte);
void						ts_lexer_goto(Lexer *self, Length position);
TSRange					   *ts_lexer_included_ranges(const Lexer *self, uint32_t *count);
void						ts_lexer_init(Lexer *self);
void						ts_lexer_mark_end(Lexer *self);
void						ts_lexer_reset(Lexer *self, Length position);
bool						ts_lexer_set_included_ranges(Lexer *self, const TSRange *ranges, uint32_t count);
void						ts_lexer_set_input(Lexer *self, TSInput input);
void						ts_lexer_start(Lexer *self);
TSSymbol					ts_lookahead_iterator_current_symbol(const TSLookaheadIterator *self);
const char				   *ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator *self);
void						ts_lookahead_iterator_delete(TSLookaheadIterator *self);
const TSLanguage		   *ts_lookahead_iterator_language(const TSLookaheadIterator *self);
TSLookaheadIterator		   *ts_lookahead_iterator_new(const TSLanguage *self, TSStateId state);
bool						ts_lookahead_iterator_next(TSLookaheadIterator *self);
bool						ts_lookahead_iterator_reset(TSLookaheadIterator *self, const TSLanguage *language, TSStateId state);
bool						ts_lookahead_iterator_reset_state(TSLookaheadIterator *self, TSStateId state);
void					   *ts_malloc_default(size_t size);
TSNode						ts_node_child(TSNode self, uint32_t child_index);
TSNode						ts_node_child_by_field_id(TSNode self, TSFieldId field_id);
TSNode						ts_node_child_by_field_name(TSNode self, const char *name, uint32_t name_length);
TSNode						ts_node_child_containing_descendant(TSNode self, TSNode subnode);
uint32_t					ts_node_child_count(TSNode self);
uint32_t					ts_node_descendant_count(TSNode self);
TSNode						ts_node_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end);
TSNode						ts_node_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end);
void						ts_node_edit(TSNode *self, const TSInputEdit *edit);
uint32_t					ts_node_end_byte(TSNode self);
TSPoint						ts_node_end_point(TSNode self);
bool						ts_node_eq(TSNode self, TSNode other);
const char				   *ts_node_field_name_for_child(TSNode self, uint32_t child_index);
TSNode						ts_node_first_child_for_byte(TSNode self, uint32_t byte);
TSNode						ts_node_first_named_child_for_byte(TSNode self, uint32_t byte);
TSSymbol					ts_node_grammar_symbol(TSNode self);
const char				   *ts_node_grammar_type(TSNode self);
bool						ts_node_has_changes(TSNode self);
bool						ts_node_has_error(TSNode self);
bool						ts_node_is_error(TSNode self);
bool						ts_node_is_extra(TSNode self);
bool						ts_node_is_missing(TSNode self);
bool						ts_node_is_named(TSNode self);
bool						ts_node_is_null(TSNode self);
const TSLanguage		   *ts_node_language(TSNode self);
TSNode						ts_node_named_child(TSNode self, uint32_t child_index);
uint32_t					ts_node_named_child_count(TSNode self);
TSNode						ts_node_named_descendant_for_byte_range(TSNode self, uint32_t start, uint32_t end);
TSNode						ts_node_named_descendant_for_point_range(TSNode self, TSPoint start, TSPoint end);
TSNode						ts_node_new(const TSTree *tree, const Subtree *subtree, Length position, TSSymbol alias);
TSNode						ts_node_next_named_sibling(TSNode self);
TSStateId					ts_node_next_parse_state(TSNode self);
TSNode						ts_node_next_sibling(TSNode self);
TSNode						ts_node_parent(TSNode self);
TSStateId					ts_node_parse_state(TSNode self);
TSNode						ts_node_prev_named_sibling(TSNode self);
TSNode						ts_node_prev_sibling(TSNode self);
uint32_t					ts_node_start_byte(TSNode self);
TSPoint						ts_node_start_point(TSNode self);
char					   *ts_node_string(TSNode self);
TSSymbol					ts_node_symbol(TSNode self);
const char				   *ts_node_type(TSNode self);
void						ts_parser__accept(TSParser *self, StackVersion version, Subtree lookahead);
bool						ts_parser__advance(TSParser *self, StackVersion version, bool allow_node_reuse);
bool						ts_parser__better_version_exists(TSParser *self, StackVersion version, bool is_in_error, unsigned cost);
void						ts_parser__breakdown_lookahead(TSParser *self, Subtree *lookahead, TSStateId state, ReusableNode *reusable_node);
bool						ts_parser__breakdown_top_of_stack(TSParser *self, StackVersion version);
bool						ts_parser__call_keyword_lex_fn(TSParser *self, TSLexMode lex_mode);
bool						ts_parser__call_main_lex_fn(TSParser *self, TSLexMode lex_mode);
bool						ts_parser__can_reuse_first_leaf(TSParser *self, TSStateId state, Subtree tree, TableEntry *table_entry);
ErrorComparison				ts_parser__compare_versions(TSParser *self, ErrorStatus a, ErrorStatus b);
unsigned					ts_parser__condense_stack(TSParser *self);
bool						ts_parser__do_all_potential_reductions(TSParser *self, StackVersion starting_version, TSSymbol lookahead_symbol);
void						ts_parser__external_scanner_create(TSParser *self);
void						ts_parser__external_scanner_deserialize(TSParser *self, Subtree external_token);
void						ts_parser__external_scanner_destroy(TSParser *self);
bool						ts_parser__external_scanner_scan(TSParser *self, TSStateId external_lex_state);
unsigned					ts_parser__external_scanner_serialize(TSParser *self);
Subtree						ts_parser__get_cached_token(TSParser *self, TSStateId state, size_t position, Subtree last_external_token, TableEntry *table_entry);
void						ts_parser__handle_error(TSParser *self, StackVersion version, Subtree lookahead);
bool						ts_parser__has_included_range_difference(const TSParser *self, uint32_t start_position, uint32_t end_position);
Subtree						ts_parser__lex(TSParser *self, StackVersion version, TSStateId parse_state);
void						ts_parser__log(TSParser *self);
void						ts_parser__recover(TSParser *self, StackVersion version, Subtree lookahead);
bool						ts_parser__recover_to_state(TSParser *self, StackVersion version, unsigned depth, TSStateId goal_state);
StackVersion				ts_parser__reduce(TSParser *self, StackVersion version, TSSymbol symbol, uint32_t count, int dynamic_precedence, uint16_t production_id, bool is_fragile, bool end_of_non_terminal_extra);
Subtree						ts_parser__reuse_node(TSParser *self, StackVersion version, TSStateId *state, uint32_t position, Subtree last_external_token, TableEntry *table_entry);
bool						ts_parser__select_children(TSParser *self, Subtree left, const SubtreeArray *children);
bool						ts_parser__select_tree(TSParser *self, Subtree left, Subtree right);
void						ts_parser__set_cached_token(TSParser *self, uint32_t byte_index, Subtree last_external_token, Subtree token);
void						ts_parser__shift(TSParser *self, StackVersion version, TSStateId state, Subtree lookahead, bool extra);
ErrorStatus					ts_parser__version_status(TSParser *self, StackVersion version);
const size_t			   *ts_parser_cancellation_flag(const TSParser *self);
void						ts_parser_delete(TSParser *self);
bool						ts_parser_has_outstanding_parse(TSParser *self);
const TSRange			   *ts_parser_included_ranges(const TSParser *self, uint32_t *count);
const TSLanguage		   *ts_parser_language(const TSParser *self);
TSLogger					ts_parser_logger(const TSParser *self);
TSParser				   *ts_parser_new(void);
TSTree					   *ts_parser_parse(TSParser *self, const TSTree *old_tree, TSInput input);
TSTree					   *ts_parser_parse_string(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length);
TSTree					   *ts_parser_parse_string_encoding(TSParser *self, const TSTree *old_tree, const char *string, uint32_t length, TSInputEncoding encoding);
void						ts_parser_print_dot_graphs(TSParser *self, int fd);
void						ts_parser_reset(TSParser *self);
void						ts_parser_set_cancellation_flag(TSParser *self, const size_t *flag);
bool						ts_parser_set_included_ranges(TSParser *self, const TSRange *ranges, uint32_t count);
bool						ts_parser_set_language(TSParser *self, const TSLanguage *language);
void						ts_parser_set_logger(TSParser *self, TSLogger logger);
void						ts_parser_set_timeout_micros(TSParser *self, uint64_t timeout_micros);
void						ts_parser_set_wasm_store(TSParser *self, TSWasmStore *store);
TSWasmStore				   *ts_parser_take_wasm_store(TSParser *self);
uint64_t					ts_parser_timeout_micros(const TSParser *self);
void						ts_query__add_negated_fields(TSQuery *self, uint16_t step_index, TSFieldId *field_ids, uint16_t field_count);
bool						ts_query__analyze_patterns(TSQuery *self, unsigned *error_offset);
TSQueryError				ts_query__parse_pattern(TSQuery *self, Stream *stream, uint32_t depth, bool is_immediate, CaptureQuantifiers *capture_quantifiers);
TSQueryError				ts_query__parse_predicate(TSQuery *self, Stream *stream);
TSQueryError				ts_query__parse_string_literal(TSQuery *self, Stream *stream);
void						ts_query__perform_analysis(TSQuery *self, const AnalysisSubgraphArray *subgraphs, QueryAnalysis *analysis);
bool						ts_query__step_is_fallible(const TSQuery *self, uint16_t step_index);
uint32_t					ts_query_capture_count(const TSQuery *self);
const char				   *ts_query_capture_name_for_id(const TSQuery *self, uint32_t index, uint32_t *length);
TSQuantifier				ts_query_capture_quantifier_for_id(const TSQuery *self, uint32_t pattern_index, uint32_t capture_index);
void						ts_query_cursor__add_state(TSQueryCursor *self, const PatternEntry *pattern);
void						ts_query_cursor__capture(TSQueryCursor *self, QueryState *state, QueryStep *step, TSNode node);
void						ts_query_cursor__compare_captures(TSQueryCursor *self, QueryState *left_state, QueryState *right_state, bool *left_contains_right, bool *right_contains_left);
int							ts_query_cursor__compare_nodes(TSNode left, TSNode right);
QueryState				   *ts_query_cursor__copy_state(TSQueryCursor *self, QueryState **state_ref);
bool						ts_query_cursor__first_in_progress_capture(TSQueryCursor *self, uint32_t *state_index, uint32_t *byte_offset, uint32_t *pattern_index, bool *root_pattern_guaranteed);
CaptureList				   *ts_query_cursor__prepare_to_capture(TSQueryCursor *self, QueryState *state, unsigned state_index_to_preserve);
void						ts_query_cursor_delete(TSQueryCursor *self);
bool						ts_query_cursor_did_exceed_match_limit(const TSQueryCursor *self);
void						ts_query_cursor_exec(TSQueryCursor *self, const TSQuery *query, TSNode node);
uint32_t					ts_query_cursor_match_limit(const TSQueryCursor *self);
TSQueryCursor			   *ts_query_cursor_new(void);
bool						ts_query_cursor_next_capture(TSQueryCursor *self, TSQueryMatch *match, uint32_t *capture_index);
bool						ts_query_cursor_next_match(TSQueryCursor *self, TSQueryMatch *match);
void						ts_query_cursor_remove_match(TSQueryCursor *self, uint32_t match_id);
void						ts_query_cursor_set_byte_range(TSQueryCursor *self, uint32_t start_byte, uint32_t end_byte);
void						ts_query_cursor_set_match_limit(TSQueryCursor *self, uint32_t limit);
void						ts_query_cursor_set_max_start_depth(TSQueryCursor *self, uint32_t max_start_depth);
void						ts_query_cursor_set_point_range(TSQueryCursor *self, TSPoint start_point, TSPoint end_point);
void						ts_query_delete(TSQuery *self);
void						ts_query_disable_capture(TSQuery *self, const char *name, uint32_t length);
void						ts_query_disable_pattern(TSQuery *self, uint32_t pattern_index);
bool						ts_query_is_pattern_guaranteed_at_step(const TSQuery *self, uint32_t byte_offset);
bool						ts_query_is_pattern_non_local(const TSQuery *self, uint32_t pattern_index);
bool						ts_query_is_pattern_rooted(const TSQuery *self, uint32_t pattern_index);
TSQuery					   *ts_query_new(const TSLanguage *language, const char *source, uint32_t source_len, uint32_t *error_offset, TSQueryError *error_type);
uint32_t					ts_query_pattern_count(const TSQuery *self);
const TSQueryPredicateStep *ts_query_predicates_for_pattern(const TSQuery *self, uint32_t pattern_index, uint32_t *step_count);
uint32_t					ts_query_start_byte_for_pattern(const TSQuery *self, uint32_t pattern_index);
uint32_t					ts_query_string_count(const TSQuery *self);
const char				   *ts_query_string_value_for_id(const TSQuery *self, uint32_t index, uint32_t *length);
void						ts_range_array_add(TSRangeArray *self, Length start, Length end);
void						ts_range_array_get_changed_ranges(const TSRange *old_ranges, unsigned old_range_count, const TSRange *new_ranges, unsigned new_range_count, TSRangeArray *differences);
bool						ts_range_array_intersects(const TSRangeArray *self, unsigned start_index, uint32_t start_byte, uint32_t end_byte);
void					   *ts_realloc_default(void *buffer, size_t size);
void						ts_set_allocator(void *(*new_malloc)(void), void *(*new_calloc)(void), void *(*new_realloc)(void), void (*new_free)(void));
void						ts_stack__add_slice(Stack *self, StackVersion original_version, StackNode *node, SubtreeArray *subtrees);
StackVersion				ts_stack__add_version(Stack *self, StackVersion original_version, StackNode *node);
bool						ts_stack_can_merge(Stack *self, StackVersion version1, StackVersion version2);
void						ts_stack_clear(Stack *self);
StackVersion				ts_stack_copy_version(Stack *self, StackVersion version);
void						ts_stack_delete(Stack *self);
int							ts_stack_dynamic_precedence(Stack *self, StackVersion version);
unsigned					ts_stack_error_cost(const Stack *self, StackVersion version);
StackSummary			   *ts_stack_get_summary(Stack *self, StackVersion version);
void						ts_stack_halt(Stack *self, StackVersion version);
bool						ts_stack_has_advanced_since_error(const Stack *self, StackVersion version);
bool						ts_stack_is_active(const Stack *self, StackVersion version);
bool						ts_stack_is_halted(const Stack *self, StackVersion version);
bool						ts_stack_is_paused(const Stack *self, StackVersion version);
Subtree						ts_stack_last_external_token(const Stack *self, StackVersion version);
bool						ts_stack_merge(Stack *self, StackVersion version1, StackVersion version2);
Stack					   *ts_stack_new(SubtreePool *subtree_pool);
unsigned					ts_stack_node_count_since_error(const Stack *self, StackVersion version);
void						ts_stack_pause(Stack *self, StackVersion version, Subtree lookahead);
StackSliceArray				ts_stack_pop_all(Stack *self, StackVersion version);
StackSliceArray				ts_stack_pop_count(Stack *self, StackVersion version, uint32_t count);
SubtreeArray				ts_stack_pop_error(Stack *self, StackVersion version);
StackSliceArray				ts_stack_pop_pending(Stack *self, StackVersion version);
Length						ts_stack_position(const Stack *self, StackVersion version);
bool						ts_stack_print_dot_graph(Stack *self, const TSLanguage *language, FILE *f);
void						ts_stack_push(Stack *self, StackVersion version, Subtree subtree, bool pending, TSStateId state);
void						ts_stack_record_summary(Stack *self, StackVersion version, unsigned max_depth);
void						ts_stack_remove_version(Stack *self, StackVersion version);
void						ts_stack_renumber_version(Stack *self, StackVersion v1, StackVersion v2);
Subtree						ts_stack_resume(Stack *self, StackVersion version);
void						ts_stack_set_last_external_token(Stack *self, StackVersion version, Subtree token);
TSStateId					ts_stack_state(const Stack *self, StackVersion version);
void						ts_stack_swap_versions(Stack *self, StackVersion v1, StackVersion v2);
uint32_t					ts_stack_version_count(const Stack *self);
const char				   *ts_string_input_read(void *_self, uint32_t byte, TSPoint point, uint32_t *length);
void						ts_subtree__compress(MutableSubtree self, unsigned count, const TSLanguage *language, MutableSubtreeArray *stack);
void						ts_subtree__print_dot_graph(const Subtree *self, uint32_t start_offset, const TSLanguage *language, TSSymbol alias_symbol, FILE *f);
size_t						ts_subtree__write_char_to_string(char *str, size_t n, int32_t chr);
size_t						ts_subtree__write_to_string(Subtree self, char *string, size_t limit, const TSLanguage *language, bool include_all, TSSymbol alias_symbol, bool alias_is_named, const char *field_name);
void						ts_subtree_array_clear(SubtreePool *pool, SubtreeArray *self);
void						ts_subtree_array_copy(SubtreeArray self, SubtreeArray *dest);
void						ts_subtree_array_delete(SubtreePool *pool, SubtreeArray *self);
void						ts_subtree_array_remove_trailing_extras(SubtreeArray *self, SubtreeArray *destination);
void						ts_subtree_array_reverse(SubtreeArray *self);
void						ts_subtree_balance(Subtree self, SubtreePool *pool, const TSLanguage *language);
MutableSubtree				ts_subtree_clone(Subtree self);
int							ts_subtree_compare(Subtree left, Subtree right, SubtreePool *pool);
Subtree						ts_subtree_edit(Subtree self, const TSInputEdit *input_edit, SubtreePool *pool);
const ExternalScannerState *ts_subtree_external_scanner_state(Subtree self);
bool						ts_subtree_external_scanner_state_eq(Subtree self, Subtree other);
unsigned					ts_subtree_get_changed_ranges(const Subtree *old_tree, const Subtree *new_tree, TreeCursor *cursor1, TreeCursor *cursor2, const TSLanguage *language, const TSRangeArray *included_range_differences, TSRange **ranges);
bool						ts_subtree_has_trailing_empty_descendant(Subtree self, Subtree other);
Subtree						ts_subtree_last_external_token(Subtree tree);
MutableSubtree				ts_subtree_make_mut(SubtreePool *pool, Subtree self);
Subtree						ts_subtree_new_error(SubtreePool *pool, int32_t lookahead_char, Length padding, Length size, uint32_t bytes_scanned, TSStateId parse_state, const TSLanguage *language);
Subtree						ts_subtree_new_error_node(SubtreeArray *children, bool extra, const TSLanguage *language);
Subtree						ts_subtree_new_leaf(SubtreePool *pool, TSSymbol symbol, Length padding, Length size, uint32_t lookahead_bytes, TSStateId parse_state, bool has_external_tokens, bool depends_on_column, bool is_keyword, const TSLanguage *language);
Subtree						ts_subtree_new_missing_leaf(SubtreePool *pool, TSSymbol symbol, Length padding, uint32_t lookahead_bytes, const TSLanguage *language);
MutableSubtree				ts_subtree_new_node(TSSymbol symbol, SubtreeArray *children, unsigned production_id, const TSLanguage *language);
SubtreeHeapData			   *ts_subtree_pool_allocate(SubtreePool *self);
void						ts_subtree_pool_delete(SubtreePool *self);
void						ts_subtree_pool_free(SubtreePool *self, SubtreeHeapData *tree);
SubtreePool					ts_subtree_pool_new(uint32_t capacity);
void						ts_subtree_print_dot_graph(Subtree self, const TSLanguage *language, FILE *f);
void						ts_subtree_release(SubtreePool *pool, Subtree self);
void						ts_subtree_retain(Subtree self);
void						ts_subtree_set_symbol(MutableSubtree *self, TSSymbol symbol, const TSLanguage *language);
char					   *ts_subtree_string(Subtree self, TSSymbol alias_symbol, bool alias_is_named, const TSLanguage *language, bool include_all);
void						ts_subtree_summarize_children(MutableSubtree self, const TSLanguage *language);
TSTree					   *ts_tree_copy(const TSTree *self);
TSTreeCursor				ts_tree_cursor_copy(const TSTreeCursor *_cursor);
uint32_t					ts_tree_cursor_current_depth(const TSTreeCursor *_self);
uint32_t					ts_tree_cursor_current_descendant_index(const TSTreeCursor *_self);
TSFieldId					ts_tree_cursor_current_field_id(const TSTreeCursor *_self);
const char				   *ts_tree_cursor_current_field_name(const TSTreeCursor *_self);
TSNode						ts_tree_cursor_current_node(const TSTreeCursor *_self);
void						ts_tree_cursor_current_status(const TSTreeCursor *_self, TSFieldId *field_id, bool *has_later_siblings, bool *has_later_named_siblings, bool *can_have_later_siblings_with_this_field, TSSymbol *supertypes, unsigned *supertype_count);
void						ts_tree_cursor_delete(TSTreeCursor *_self);
void						ts_tree_cursor_goto_descendant(TSTreeCursor *_self, uint32_t goal_descendant_index);
bool						ts_tree_cursor_goto_first_child(TSTreeCursor *self);
int64_t						ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor *self, uint32_t goal_byte);
int64_t						ts_tree_cursor_goto_first_child_for_point(TSTreeCursor *self, TSPoint goal_point);
TreeCursorStep				ts_tree_cursor_goto_first_child_internal(TSTreeCursor *_self);
bool						ts_tree_cursor_goto_last_child(TSTreeCursor *self);
TreeCursorStep				ts_tree_cursor_goto_last_child_internal(TSTreeCursor *_self);
bool						ts_tree_cursor_goto_next_sibling(TSTreeCursor *self);
TreeCursorStep				ts_tree_cursor_goto_next_sibling_internal(TSTreeCursor *_self);
bool						ts_tree_cursor_goto_parent(TSTreeCursor *_self);
bool						ts_tree_cursor_goto_previous_sibling(TSTreeCursor *self);
TreeCursorStep				ts_tree_cursor_goto_previous_sibling_internal(TSTreeCursor *_self);
TreeCursorStep				ts_tree_cursor_goto_sibling_internal(TSTreeCursor *_self, bool (*advance)(CursorChildIterator *, TreeCursorEntry *, bool *));
void						ts_tree_cursor_init(TreeCursor *self, TSNode node);
TSTreeCursor				ts_tree_cursor_new(TSNode node);
TSNode						ts_tree_cursor_parent_node(const TSTreeCursor *_self);
void						ts_tree_cursor_reset(TSTreeCursor *_self, TSNode node);
void						ts_tree_cursor_reset_to(TSTreeCursor *_dst, const TSTreeCursor *_src);
void						ts_tree_delete(TSTree *self);
void						ts_tree_edit(TSTree *self, const TSInputEdit *edit);
TSRange					   *ts_tree_get_changed_ranges(const TSTree *old_tree, const TSTree *new_tree, uint32_t *length);
TSRange					   *ts_tree_included_ranges(const TSTree *self, uint32_t *length);
const TSLanguage		   *ts_tree_language(const TSTree *self);
TSTree					   *ts_tree_new(Subtree root, const TSLanguage *language, const TSRange *included_ranges, unsigned included_range_count);
void						ts_tree_print_dot_graph(const TSTree *self, int file_descriptor);
TSNode						ts_tree_root_node(const TSTree *self);
TSNode						ts_tree_root_node_with_offset(const TSTree *self, uint32_t offset_bytes, TSPoint offset_extent);
